import{_ as d,r as i,o as r,c,b as a,d as e,e as s,a as n}from"./app-ff2f634e.js";const o={},l=n('<h3 id="说下事件模型" tabindex="-1"><a class="header-anchor" href="#说下事件模型" aria-hidden="true">#</a> 说下事件模型</h3><h4 id="_1-什么是事件和事件流" tabindex="-1"><a class="header-anchor" href="#_1-什么是事件和事件流" aria-hidden="true">#</a> <a href="#"></a>1. 什么是事件和事件流</h4><p>javascript 是事件驱动型语言。当用户在网页中进行某种操作时，就产生了一个“事件”(Event)。当事件发生时，JavaScript 可以对之做出响应，具体如何响应某个事件由编写的事件处理函数完成。</p>',3),h={href:"https://so.csdn.net/so/search?q=%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},u=n(`<h4 id="_2-冒泡和捕获的区别-触发顺序" tabindex="-1"><a class="header-anchor" href="#_2-冒泡和捕获的区别-触发顺序" aria-hidden="true">#</a> <a href="#"></a>2. 冒泡和捕获的区别，触发顺序</h4><p>IE 提出的事件流是事件冒泡，即从下至上，从目标触发的元素逐级向上传播，直到 window 对象。</p><p>Netscape 的事件流就是事件捕获，即从 document 逐级向下传播到目标元素。由于 IE 低版本浏览器不支持，所以很少使用事件捕获。</p><p>后来 ECMAScript 在 DOM2 中对事件流进行了进一步规范，基本上就是上述二者的结合。</p><blockquote><p>DOM2级事件规定的事件流包括三个阶段： （1）事件捕获阶段 （2）处于目标阶段 （3）事件冒泡阶段</p></blockquote><h4 id="_3-冒泡和捕获的使用方式、应用场景" tabindex="-1"><a class="header-anchor" href="#_3-冒泡和捕获的使用方式、应用场景" aria-hidden="true">#</a> <a href="#"></a>3. 冒泡和捕获的使用方式、应用场景</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>\`//给body侦听点击事件，冒泡阶段执行
 document.body.addEventListener(&quot;click&quot;, clickHandler);
 //给body侦听点击事件，捕获阶段执行
 document.body.addEventListener(&quot;click&quot;, clickHandler,true);
 //给body侦听点击事件，只执行一次
 document.body.addEventListener(&quot;click&quot;, clickHandler,{once:true});
// 事件侦听添加（注册事件）占有内存的，所以当删除对象时，一定要将对象上的侦听事件移除
 document.body.removeEventListener(&quot;click&quot;, clickHandler);\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>onclick支持IE低版本，addEventListener不支持IE8一下，低版本的IE使用 attachEvent 进行事件侦听；使用 detachEvent 移除事件侦听。</p></blockquote><h4 id="_4-如何阻止冒泡" tabindex="-1"><a class="header-anchor" href="#_4-如何阻止冒泡" aria-hidden="true">#</a> <a href="#"></a>4. 如何阻止冒泡</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>\`e.stopPropagation();
e.cancelBubble=true // IE8及以下浏览器\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-什么是事件委托" tabindex="-1"><a class="header-anchor" href="#_5-什么是事件委托" aria-hidden="true">#</a> <a href="#"></a>5. 什么是事件委托</h4><p>添加事件侦听（注册事件）占有内存的，尽量减少事件侦听的数量，将子元素的事件委托给父元素来执行，叫做事件委托。</p><p>事件委托利用的就是冒泡的原理。</p><p>当删除对象时，一定要将对象上的侦听事件移除，否则会造成内存泄露。</p><blockquote><p>如果有多个DOM节点需要监听事件的情况下，给每个DOM绑定监听函数，会极大的影响页面的性能，因此我们通过事件委托来进行优化。</p></blockquote>`,15);function p(v,b){const t=i("ExternalLinkIcon");return r(),c("div",null,[l,a("p",null,[e("事件流描述的就是从页面中接收事件的顺序，早期 IE 和 Netscape 提出了完全相反的事件流概念，IE 事件流是"),a("a",h,[e("事件冒泡"),s(t)]),e("，而Netscape的事件流就是事件捕获。")]),u])}const _=d(o,[["render",p],["__file","shuoxiashijianmoxing.html.vue"]]);export{_ as default};
