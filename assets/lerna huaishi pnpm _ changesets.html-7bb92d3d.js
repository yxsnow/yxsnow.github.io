import{_ as e,o as p,c as a,a as s}from"./app-ff2f634e.js";const t="/assets/v2-cf490506848a062fe67bb7382c323_d2858394bfcd44589-a117ac5c.webp",n="/assets/v2-eeaba3818f24bb844e0cf3fbceb2e_00ed2cf2f68746cf9-3f92dcbf.webp",c="/assets/v2-ff74d2d8d0e6e61ce680f50cb014f_fbaa673088c14b1d9-d9e8d3a6.webp",d="/assets/v2-fe253c5187336e41dab00caa6ec1f_3969870a56f6402eb-844f1306.webp",i="/assets/v2-910b679662c6e0022375fd5d292b5_e74e97204da04ae3a-8a8a8a60.webp",r="/assets/v2-e6a1ed0e51672828852d70a4ff3a3_a0e1d7bffe414e088-515660fa.webp",o="/assets/v2-f7ca42737ac207488faebf9162551_0a8091737e994ea0b-42b33045.webp",b="/assets/v2-a191d40172df751476bf66f82a699_6ea42e7fe9ae48dca-625f76da.webp",m="/assets/v2-5b259504067cf7a7df109c1c3c956_28bc9a45d6254fefa-5f7f3bd5.webp",l="/assets/v2-098f6eb61701b8ac59c9e7ff8a9f5_7cf84ef179144f2f8-0133f389.webp",g="/assets/v2-d8cdf573ba185b65b0b533b52e188_457adcc2e7e34fe7a-da799f6a.webp",h="/assets/v2-55835d77892f77e299fbd279ba5be_6446a9913f0443e29-38944adc.webp",_="/assets/v2-ec79f22bbd290b45d56d9a02e2b4d_20a881fd2d1742558-3368b17e.webp",f="/assets/v2-5db221b281401bdb234845716bd13_48d8268f338d4e568-d81e1c56.webp",v="/assets/v2-33b5212d5c3966d02a8c5289e4d45_1db1c70e37da42369-4f2a7bfb.webp",w="/assets/v2-1c5858b3046ef228ba0ba4941c06b_c63342adcadc4a56b-56c4e167.webp",u="/assets/v2-eb34449f208a5218afd46edb59c71_03d64c5f498743089-8b2b103a.webp",x="/assets/v2-3076d747276d7e92150df3bd52787_87db8e6291ac41c1b-59d2e122.webp",k="/assets/v2-62be490a2bbd7e8107c989ec9a24e_488bf70d64de42808-663556f8.webp",y="/assets/v2-25c1936cbf53b67c5e3b6d36a8e57_2b16c8d695be4dc99-ff5acf18.webp",j="/assets/v2-198068f8ce67a0a87783804abc75a_14574ef07f5f4cabb-deacd490.webp",G="/assets/v2-cf0acc4de324b4fbe20a5fc343ee5_c18c735733dc45eea-9b253cbe.webp",E="/assets/v2-50281f11fa629ff1a03d9e1aedb5b_382c4db3b40f47d9a-7d074565.webp",N="/assets/v2-3810b7423831daedc869fa410399f_52844062b1f24f4a9-d8bd4e8d.webp",A="/assets/v2-e849be0eb64aaf14229efcc142170_996b86cfa4444631a-b75b0f63.webp",B="/assets/v2-dedd0846a5682952737deb2b42598_6c4311e8d1014d95a-142a86f6.webp",C="/assets/v2-f43dd56d2a743cb52bd007aaabc57_4c6c311d55e94395a-738583f4.webp",H="/assets/v2-29399785efa8d52cb9d11ba448ee8_cb34216207a4435fb-ce72fa6b.webp",L="/assets/v2-33c56d8746238a8624e1e590989c1_5cdc078c8bf243249-1d2ddf66.webp",O="/assets/v2-68b4185b47fbb2bd34a867b0aa8d1_9bff12c85dca4eb48-3e853f18.webp",z="/assets/v2-ce4437abfabd9ea55f2e0c54d44df_7eb2e462af6d439fa-edf0f6d9.webp",S="/assets/v2-d848f1a140d3f216e4252ef263ae3_3ade7dc8e69b4830a-258b6d5d.webp",V="/assets/v2-9da7248fd8b94a61fa4c77e1660ad_854ae1a5b33d4db59-13ef2f15.webp",q="/assets/v2-12bf2afafea315a75eb485e01b385_873ef5569b4e47b6a-7a82d0ac.webp",D="/assets/v2-054fd423875a07c4c9df7e4a1755f_b11de162b12749559-09d6b108.webp",F="/assets/v2-865e3f16b1766293a249b4784277c_c5457d72cdcf4724a-afd16a21.webp",I="/assets/v2-86738958e711646e1138021b77586_c70c8db800ac401bb-71863f31.webp",J="/assets/v2-a6b43314b36460324f6bad8f7a1a5_e6b802b6a9eb40a5a-ee26ca2f.webp",K="/assets/v2-05301e19800b85898942dd529d63d_5879814d051d4344a-5041f66d.webp",M="/assets/v2-27a996fe683b3c105807c62040d41_16281ee086ba44d7a-24fa5b9f.webp",P="/assets/v2-ee986a7692e703e814d99c48f931a_2d3dc5745017463da-67935493.webp",Q="/assets/v2-5506a18f32b9ed8f9a4ab76f1adbe_a8c8e40dabc74966b-ce8b0abd.webp",R={},T=s('<p>monorepo 是多个包在同一个项目中管理的方式，是很流行的项目组织形式。</p><p>主流的开源包基本都是用 monorepo 的形式管理的。</p><p>为什么用 monorepo 也很容易理解：</p><p>比如 babel 分为了 @babel/core、@babel/cli、@babel/parser、@babel/traverse、@babel/generator 等一系列包。</p><p>如果每个包单独一个仓库，那就有十多个 git 仓库，这些 git 仓库每个都要单独来一套编译、lint、发包等工程化的工具和配置，重复十多次。</p><p>工程化部分重复还不是最大的问题，最大的问题还是这三个：</p><ol><li>一个项目依赖了一个本地还在开发的包，我们会通过 npm link 的方式把这个包 link 到全局，然后再 link 到那个项目的 node_modules 下。</li></ol><p>npm link 的文档是这么写的：</p><img width="690" height="261" src="'+t+'"><p>就是把代码 link 到全局再 link 到另一个项目，这样只要这个包的代码改了，那个项目就可以直接使用最新的代码。</p><p>如果只是一个包的话，npm link 还是方便的。但现在有十几个包了，这样来十多次就很麻烦了。</p><p>2. 需要在每个包里执行命令，现在也是要分别进入到不同的目录下来执行十多次。最关键的是有一些包需要根据依赖关系来确定执行命令的先后顺序。</p><p>3. 版本更新的时候，要手动更新所有包的版本，如果这个包更新了，那么依赖它的包也要发个新版本才行。</p><p>这也是件麻烦的事情。</p><p>因为这三个问题：npm link 比较麻烦、执行命令比较麻烦、版本更新比较麻烦，所以就有了对 monorepo 的项目组织形式和工具的需求。</p><p>比如主流的 monorepo 工具 lerna，它描述自己解决的三个大问题也是这个：</p><img width="690" height="245" src="'+n+'"><p>也就是说，把理清了这三个点，就算是掌握了 monorepo 工具的关键了。</p><p>我们分别来看一下：</p><p>npm link 的流程实际上是这样的：</p><img width="690" height="461" src="'+c+'"><p>npm 包先 link 到全局，再 link 到另一个项目的 node_modules。</p><p>而 monorepo 工具都是这样做的：</p><p><img src="'+d+`" alt=""></p><p>比如一个 monorepo 项目下有 a、b、c 三个包，那么 monorepo 工具会把它们 link 到父级目录的 node_modules。</p><p>node 查找模块的时候，一层层往上查找，就都能找到彼此了，就完成了 a、b、c 的相互依赖。</p><p>比如用 lerna 的 demo 项目试试：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone https://github.com/lerna/getting-started-example.git 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下载下来是这样的结构：</p><p><img src="`+i+'" alt=""></p><p>执行 npm install，在根目录的 node_modules 下就会安装很多依赖。</p><p>包括我们刚说的 link 到根 node_modules 里的包：</p><p><img src="'+r+'" alt=""></p><p><img src="'+o+'" alt=""></p><p><img src="'+b+`" alt=""></p><p>这个箭头就是软链接文件的意思。</p><p>底层都是系统提供的 ln -s 的命令。</p><p>比如我执行</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ln -s package.json package2.json 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那就是创建一个 package2.json 的软连接文件，内容和 package.json 一样。</p><p>这俩其实是一个文件，一个改了另一个也就改了：</p><p><img src="https://pic1.zhimg.com/v2-8e11ebd558622535267a8a3972330e54_b.jpg" alt="动图封面"></p><p>原理都是软连接，只不过 npm link 的那个和 monorepo 这个封装的有点区别。</p><p>这种功能本来是 lerna 先实现的，它提供了 lerna bootstrap 来完成这种 link：</p><img width="690" height="144" src="`+m+'"><p>只不过后来 npm、yarn、pnpm 都内置了这个功能，叫做 workspace。就不再需要 lerna 这个 bootstrap 的命令了。</p><p>直接在 package.json 里配置 workspace 的目录：</p><p><img src="'+l+'" alt=""></p><p>然后 npm install，就会完成这些 package 的 link。</p><p>而包与包之间的依赖，workspace 会处理，本地开发的时候只需要写 * 就好，发布这个包的时候才会替换成具体的版本。</p><p><img src="'+g+'" alt=""></p><p>这里用的是 npm workspace：</p><img width="690" height="193" src="'+h+'"><p>它所解决的问题正如我们分析的：</p><img width="690" height="97" src="'+_+'"><p>在 npm install 的时候自动 link。</p><p>yarn workspace 也是一样的方式：</p><img width="690" height="141" src="'+f+'"><p>pnpm 有所不同，是放在一个 yaml 文件里的：</p><img width="690" height="358" src="'+v+'"><p>此外，yarn 和 pnpm 支持 workspace 协议，需要把依赖改为这样的形式：</p><p><img src="'+w+'" alt=""></p><p>这样查找依赖就是从 workspace 里查找，而不是从 npm 仓库了。</p><img width="690" height="61" src="'+u+`"><p>总之，不管是 npm workspace、yarn workspace 还是 pnpm workspace，都能达到在 npm install 的时候自动 link 的目的。</p><p>回过头来再来看 monorepo 工具的第二大功能：执行命令</p><p>在刚才的 demo 项目下执行</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>lerna run build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出是这样的：</p><img width="690" height="199" src="`+x+`"><p>lerna 会按照依赖的拓扑顺序来执行命令，并且合并输出执行结果。</p><p>比如 remixapp 依赖了 header 和 footer 包，所以先在 footer 和 header 下执行，再在 remixapp 下执行。</p><p>当然，npm workspace、yarn workspace、pnpm workspace 也是提供了多包执行命令的支持的。</p><p>npm workspace 执行刚才的命令是这样的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm exec --workspaces -- npm run build 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以简写为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm exec -ws -- npm run build 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img width="690" height="338" src="`+k+`"><p>也可以单独执行某个包下执行：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm exec --workspace header --workspace footer -- npm run build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以简写为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npm exec -w header -w footer  -- npm run build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>只不过不支持拓扑顺序。</p><p>yarn workspace 可以执行：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>yarn workspaces run build 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img width="690" height="523" src="`+y+'"><p>但也同样不支持拓扑顺序。</p><p>我们再来试试 pnpm workspace。</p><p>npm workspace 和 yarn workspace 只要在 package.json 里声明 workspaces 就可以。</p><p>但 pnpm workspace 要声明在 pnpm-workspaces.yaml 里：</p><p><img src="'+j+`" alt=""></p><p>pnpm 在 workspace 执行命令是这样的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>pnpm exec -r pnpm run build 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>-r 是递归的意思：</p><p><img src="`+G+'" alt=""></p><p>关键是 pnpm 是支持选择拓扑排序，然后再执行命令的：</p><img width="690" height="279" src="'+E+`"><p>有时候命令有执行先后顺序的要求的时候就很有用了。</p><p>总之，npm、yarn、pnpm 都和 lerna 一样支持 workspace 下命令的执行，而且 pnpm 和 lerna 都是支持拓扑排序的。</p><p>再来看最后一个 monorepo 工具的功能：版本管理和发布。</p><p>有个工具叫做 changesets 是专门做这个的，我们看下它能做啥就好了。</p><p>执行 changeset init：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npx changeset init
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行之后会多这样一个目录：</p><p><img src="`+N+`" alt=""></p><p>然后添加一个 changeset。</p><p>什么叫 changeset 呢？</p><p>就是一次改动的集合，可能一次改动会涉及到多个 package，多个包的版本更新，这合起来叫做一个 changeset。</p><p>我们执行 add 命令添加一个 changeset：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npx changeset add 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>会让你选一个项目：</p><img width="690" height="171" src="`+A+'"><p>哪个是 major 版本更新，哪个是 minor 版本更新，剩下的就是 pacth 版本更新。</p><img width="690" height="136" src="'+B+'"><p>1.2.3 这里面 1 就是 major 版本、2 是 minor 版本、3 是 patch 版本。</p><p>之后会让你输入这次变更的信息：</p><img width="690" height="71" src="'+C+'"><p>然后你就会发现在 .changeset 下多了一个文件记录着这次变更的信息：</p><img width="690" height="184" src="'+H+`"><p>然后你可以执行 version 命令来生成最终的 CHANGELOG.md 还有更新版本信息：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npx changeset version 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>之后那些临时的 changeset 文件就消失了：</p><p><img src="`+L+'" alt=""></p><p>更改的包下都多了 CHANGELOG.md 文件：</p><img width="690" height="219" src="'+O+'"><img width="690" height="215" src="'+z+'"><p>并且都更新了版本号：</p><img width="690" height="168" src="'+S+'"><img width="690" height="199" src="'+V+'"><p>而且 remixapp 这个包虽然没有更新，但是因为依赖的包更新了，所以也更新了一个 patch 版本：</p><img width="690" height="235" src="'+q+'"><img width="690" height="222" src="'+D+'"><p>这就是 changeset 的作用。</p><p>如果没有这个工具呢？</p><p>你要自己一个个去更新版本号，而且你还得分析依赖关系，知道这个包被哪些包用到了，再去更改那些依赖这个包的包的版本。</p><p>就很麻烦。</p><p>这就是 monorepo 工具的版本更新功能。</p><p>更新完版本自然是要 publish 到 npm 仓库的。</p><p>执行 changeset publish 命令就可以，并且还会自动打 tag：</p><img width="690" height="92" src="'+F+'"><p>如果你不想用 changeset publish 来发布，想用 pnpm publish，那也可以用 changeset 来打标签：</p><img width="690" height="105" src="'+I+`"><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>npx changeset tag 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img width="690" height="91" src="`+J+'"><p>这就是 monorepo 工具的版本更新和发布的功能。</p><p>lerna 是自己实现的一套，但是用 pnpm workspace + changeset 也完全可以做到。</p><p>回过头来看下这三个功能：</p><img width="690" height="215" src="'+K+'"><p>不同包的自动 link，npm workspace、yarn workspace、pnpm workspace 都可以做到，而 lerna bootstrap 也废弃了，改成基于 workspace。</p><p>执行命令这个也是都可以，只不过 lerna 和 pnpm workspace 都支持拓扑顺序执行命令。</p><p>版本更新和发布这个用 changeset 也能实现，用 lerna 的也可以。</p><p>整体看下来，似乎没啥必要用 lerna 了，用 pnpm workspace + changesets 就完全能覆盖这些需求。</p><p>那用 lerna 的意义在哪呢？</p><p>虽然功能上没啥差别，但性能还是有差别的。</p><p>lerna 还支持命令执行缓存，再就是可以分布式执行任务。</p><p>执行 lerna add-caching 来添加缓存的支持:</p><img width="690" height="296" src="'+M+'"><p>指定 build 和 test 命令是可以缓存的，输出目录是 dist。</p><p>那当再次执行的时候，如果没有变动，lerna 就会直接输出上次的结果，不会重新执行命令。</p><p>下面分别是第一次和第二次执行：</p><img width="690" height="365" src="'+P+'"><p>至于分布式执行任务这个，是 nx cloud 的功能，貌似是可以在多台机器上跑任务。</p><p>所以综合看下来，lerna 在功能上和 pnpm workspace + changesets 没啥打的区别，但是在性能上更好点。</p><p>如果项目比较大，用 lerna 还是不错的，否则用 pnpm workspace + changesets 也完全够用了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h2><p>monorepo 是在一个项目中管理多个包的项目组织形式。</p><p>它能解决很多问题：工程化配置重复、link 麻烦、执行命令麻烦、版本更新麻烦等。</p><p>lerna 在文档中说它解决了 3 个 monorepo 最大的问题：</p><ul><li>不同包的自动 link</li><li>命令的按顺序执行</li><li>版本更新、自动 tag、发布</li></ul><img width="690" height="207" src="'+Q+'"><p>这三个问题是 monorepo 的核心问题。</p><p>第一个问题用 pmpm workspace、npm workspace、yarn workspace 都可以解决。</p><p>第二个问题用 pnpm exec 也可以保证按照拓扑顺序执行，或者用 npm exec 或者 yarn exec 也可以。</p><p>第三个问题用 changesets 就可以做到。</p><p>lerna 在功能上和 pnpm workspace + changesets 并没有大的差别，主要是它做了命令缓存、分布式执行任务等性能的优化。</p><p>总之，monorepo 工具的核心就是解决这三个问题。</p>',176),U=[T];function W(X,Y){return p(),a("div",null,U)}const $=e(R,[["render",W],["__file","lerna huaishi pnpm _ changesets.html.vue"]]);export{$ as default};
