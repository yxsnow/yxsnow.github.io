import{_ as a,r as t,o as c,c as l,b as n,d as e,e as d,a as s}from"./app-ff2f634e.js";const o="/assets/1728c7ddb96a2d78_tplv-t2oaga2asx_6cc921c5c0ef4c019-0a60d96d.webp",r="/assets/1728c832e8d91288_tplv-t2oaga2asx_7d5848c2fb034ebd8-940081df.webp",v="/assets/1728c8db5c33b923_tplv-t2oaga2asx_0bbb3aecabf74ce28-64e5113b.webp",u="/assets/1728c9641c8dbb94_tplv-t2oaga2asx_0068c2a633f64f889-c80a72cc.webp",m="/assets/1728ca3e4c4704d6_tplv-t2oaga2asx_c2dfec7c998646e98-2de14911.webp",b="/assets/1728ca64af9542e7_tplv-t2oaga2asx_527ac8d9184c43179-0169ed1f.webp",p="/assets/1728caba4ceaf829_tplv-t2oaga2asx_8dc3cd9d19bd43888-d11713c6.webp",h="/assets/1728cbd76ef928de_tplv-t2oaga2asx_f046230068bf451c8-f6ff52e3.webp",g="/assets/1728caf94cf8364d_tplv-t2oaga2asx_261644dcb4cb4b1c8-398e75fe.webp",x="/assets/1728cc5228cf817e_tplv-t2oaga2asx_dd07a420cc26431aa-0ac8ab58.webp",f="/assets/1728ccdb8cec3dfe_tplv-t2oaga2asx_46c5de6357f3463e9-154f7146.webp",_="/assets/1728cd252f0b83c7_tplv-t2oaga2asx_0f6027fd4b47472f9-c341c23d.webp",j="/assets/1728cd5b0177b58a_tplv-t2oaga2asx_cb022ef5ac074848b-3a38ba9c.webp",q="/assets/172cf8b459acb1c3_tplv-t2oaga2asx_dd35f37e95df4b319-6424213e.webp",w="/assets/172d458044c94ab0_tplv-t2oaga2asx_bedb7a8841d2410f9-3ada37a9.webp",k="/assets/172d461980b3046c_tplv-t2oaga2asx_7c8fa1b70efa46ce8-c01fa2b3.webp",T="/assets/172d471cbe027552_tplv-t2oaga2asx_db070239f90b49768-ed2d9865.webp",B="/assets/172d4a4c8cc62316_tplv-t2oaga2asx_e8db1413aaee4db7a-c77f5edb.webp",C="/assets/172d4ae899617df2_tplv-t2oaga2asx_7f9c2d7c748e499ab-22121f50.webp",M="/assets/172d4b44eb1352d5_tplv-t2oaga2asx_21569855e98140269-bf5e8262.webp",E="/assets/172d4e73a892b1e8_tplv-t2oaga2asx_1ae20025716745f38-2fda4fac.webp",y="/assets/172d4f7add350cb1_tplv-t2oaga2asx_4930d16c24324f64a-4e32488d.webp",D="/assets/172d4f8d98f294e0_tplv-t2oaga2asx_113b01145ed947e6a-abec7d2d.webp",F="/assets/172d513c3a5b14f4_tplv-t2oaga2asx_d0cff1225def43fa9-16ae057d.webp",S="/assets/172d53b771ba9ba0_tplv-t2oaga2asx_daffb4f847454f989-d3a6d41f.webp",O="/assets/172d5317dcc532ca_tplv-t2oaga2asx_4d6dced034a244248-118d3202.webp",I="/assets/172d567219c97472_tplv-t2oaga2asx_64f1296baa884dadb-501086ee.webp",V="/assets/172d56b9ac2c796b_tplv-t2oaga2asx_f87d95e63b524f448-212b3afb.webp",A="/assets/172d56fe983c24fe_tplv-t2oaga2asx_81271d1f7a7844228-9ca4b85e.webp",R="/assets/172d57529786d724_tplv-t2oaga2asx_6d826a23478b467cb-8659622d.webp",L="/assets/172d57e08002e4f4_tplv-t2oaga2asx_89844595b2414136a-c8da2480.webp",J="/assets/172d5b47655fc1e6_tplv-t2oaga2asx_936cbdbd6d1c42378-8ac57ef2.webp",N="/assets/172d5b799f7b7a08_tplv-t2oaga2asx_9c28e5a29441428e9-45b316f6.webp",H="/assets/172d58753cc3fd4a_tplv-t2oaga2asx_9f9e658d60414679a-52fe92cb.webp",G="/assets/172d5932ca733f41_tplv-t2oaga2asx_61978b03ac3745be9-2831ba7c.webp",P="/assets/172d595417f99bd6_tplv-t2oaga2asx_673f9ef7656b4234a-8768dd81.webp",z="/assets/172d596144b7af8c_tplv-t2oaga2asx_1de4d36ce7f3431aa-1bb2c856.webp",K={},Q=s(`<h2 id="_1-为什么要做前端测试" tabindex="-1"><a class="header-anchor" href="#_1-为什么要做前端测试" aria-hidden="true">#</a> 1. 为什么要做前端测试</h2><p>首先，我认为前端测试并不是所有项目都必须的，因为写测试代码是需要要花费一定时间的，当项目比较简单的时候，花时间写测试代码可能反而会影响开发效率，但是需要指出的是，我们前端开发过程中，编写测试代码，有以下这些好处：</p><ol><li>更快的发现bug，让绝大多数bug在开发阶段发现解决，提高产品质量</li><li>比起写注释，单元测试可能是更好的选择，通过运行测试代码，观察输入和输出，有时会比注释更能让别人理解你的代码（当然，重要的注释还是要写的。。。）</li><li>有利于重构，如果一个项目的测试代码写的比较完善，重构过程中改动时可以迅速的通过测试代码是否通过来检查重构是否正确，大大提高重构效率</li><li>编写测试代码的过程，往往可以让我们深入思考业务流程，让我们的代码写的更完善和规范。</li></ol><h2 id="_2-什么是tdd和bdd" tabindex="-1"><a class="header-anchor" href="#_2-什么是tdd和bdd" aria-hidden="true">#</a> 2. 什么是<code>TDD</code>和<code>BDD</code></h2><h3 id="_2-1-tdd与单元测试" tabindex="-1"><a class="header-anchor" href="#_2-1-tdd与单元测试" aria-hidden="true">#</a> 2.1 <code>TDD</code>与单元测试</h3><h4 id="_2-1-1-什么是tdd" tabindex="-1"><a class="header-anchor" href="#_2-1-1-什么是tdd" aria-hidden="true">#</a> 2.1.1 什么是<code>TDD</code></h4><p>所谓<code>TDD(Test Driven Development)</code>，即测试驱动开发，简单的来说就是先编写测试代码，然后以使得所有测试代码都通过为目的，编写逻辑代码，是一种以测试来驱动开发过程的开发模式。</p><h4 id="_2-1-2-单元测试" tabindex="-1"><a class="header-anchor" href="#_2-1-2-单元测试" aria-hidden="true">#</a> 2.1.2 单元测试</h4><p>所谓单元测试<code>（unit testing）</code>，是指对软件中的最小可测试单元进行检查和验证。通俗的讲，在前端，单元可以理解为一个独立的模块文件，单元测试就是对这样一个模块文件的测试。</p><p>对于一个独立的模块（<code>ES6</code>模块），因为功能相对独立，所以我们可以首先编写测试代码，然后根据测试代码指导编写逻辑代码。</p><p>所以提到<code>TDD</code>，这里的测试一般是指单元测试</p><h3 id="_2-2-bdd与集成测试" tabindex="-1"><a class="header-anchor" href="#_2-2-bdd与集成测试" aria-hidden="true">#</a> 2.2 <code>BDD</code>与集成测试</h3><h4 id="_2-2-1-什么是bdd" tabindex="-1"><a class="header-anchor" href="#_2-2-1-什么是bdd" aria-hidden="true">#</a> 2.2.1 什么是<code>BDD</code></h4><p>所谓<code>BDD(Behavior Driven Development)</code>，即行为驱动开发，简单的来说就是先编写业务逻辑代码，然后以使得所有业务逻辑按照预期结果执行为目的，编写测试代码，是一种以用户行为来驱动开发过程的开发模式。</p><h4 id="_2-2-2-集成测试" tabindex="-1"><a class="header-anchor" href="#_2-2-2-集成测试" aria-hidden="true">#</a> 2.2.2 集成测试</h4><p>所谓集成测试<code>（Integration Testing）</code>，是指对软件中的所有模块按照设计要求进行组装为完整系统后，进行检查和验证。通俗的讲，在前端，集成测试可以理解为对多个模块实现的一个交互完整的交互流程进行测试。</p><p>对于多个模块（<code>ES6</code>模块）组成的系统，需要首先将交互行为完善，才能按照预期行为编写测试代码。</p><p>所以提到<code>BDD</code>，这里的测试一般是指集成测试。</p><h2 id="_3-jest使用-引言部分" tabindex="-1"><a class="header-anchor" href="#_3-jest使用-引言部分" aria-hidden="true">#</a> 3. <code>Jest</code>使用---引言部分</h2><h3 id="_3-1-我们如何写测试代码" tabindex="-1"><a class="header-anchor" href="#_3-1-我们如何写测试代码" aria-hidden="true">#</a> 3.1 我们如何写测试代码？</h3><p>如果我们之前从来没有接触过测试代码，那让我们自己来设计测试代码的写法，会是什么样呢？我们需要让测试代码简单，通俗易懂，比如我们举个例子如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export function findMax (arr) {
    return Math.max(...arr)
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们写了一个很简单的获取数组最大值的函数（你可能觉得这样写并不严谨，但我们为了简单，暂时假设输入是非空数值数组），如果对这个函数写一个测试其正确与否的测试程序，它可能构思是这样的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>我期望 findMax([1, 2, 4, 3]) 的结果是 4
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>进一步转化为英文：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>I expect findMax([1, 2, 4, 3]) to be 4
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>用程序性的语言表示，<code>expect</code>作为一个函数，为它传入想要测试的对象（<code>findMax</code>函数），把输出结果也做一层封装<code>toBe(4)</code>:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>expect(findMax([1, 2, 4, 3])).toBe(4)  // 有内味了
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>更进一步，我们想要增加一些描述性信息，比如</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>测试findMax函数，我期望 findMax([1, 2, 4, 3]) 的结果是 4
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候，我们可以再做一层封装，定义一个<code>test</code>函数，它有两个参数，第一个参数是一些描述性信息（这里是 测试<code>findMax</code>函数），第二个参数是一个函数，函数里可以执行我们上面的逻辑，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;findMax函数输出&#39;, () =&gt; {
    expect(findMax([1, 2, 4, 3])).toBe(4) // 内味更深了
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-简单的自己实现测试代码" tabindex="-1"><a class="header-anchor" href="#_3-2-简单的自己实现测试代码" aria-hidden="true">#</a> 3.2 简单的自己实现测试代码</h3><p>我们自己可以简单的实现下<code>test</code>函数和<code>expect</code>函数，因为存在链式调用<code>toBe</code>，所以<code>expect</code>函数最终应该返回一个具有<code>toBe</code>方法的对象，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// expect函数
function expect (value) {
    return {
        toBe: (toBeValue) =&gt; {
            if (toBeValue === value) {
                console.log(&#39;测试通过！&#39;)
            } else {
                throw new Error(&#39;测试不通过！&#39;)
            }
        }
    }
}

// test函数
function test (msg, func) {
    try {
        func()
        console.log(\`\${msg}测试过程无异常！\`)
    } catch (err) {
        console.error(\`\${msg}测试过程出错！\`)
    }
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的测试方法，只是对数字做了简单的测试，实际项目中，需要测试的类型是很多的，这个时候我们就可以选择一些比较成熟的测试框架。一个简单好用，功能强大的工具就呈现在我们面前，它就是<code>jest</code>。</p><h2 id="_4-jest使用-入门部分" tabindex="-1"><a class="header-anchor" href="#_4-jest使用-入门部分" aria-hidden="true">#</a> 4. <code>Jest</code>使用---入门部分</h2><h3 id="_4-1-准备工作" tabindex="-1"><a class="header-anchor" href="#_4-1-准备工作" aria-hidden="true">#</a> 4.1 准备工作</h3><p>我们这部分的例子主要是为了介绍<code>jest</code>最基本的用法，首先我们先简单的搭建一下演示环境。</p><p>第一步，使用<code>npm init -y</code>(我的<code>node</code>版本是<code>v12.14.1</code>，<code>npm</code>版本是<code>v6.13.4</code>)初始化项目</p>`,40),W=n("code",null,"jest",-1),$=n("code",null,"npm install --save-dev jest",-1),U={href:"https://link.juejin.cn?target=https%3A%2F%2Fjestjs.io%2Fdocs%2Fen%2Fgetting-started",title:"https://jestjs.io/docs/en/getting-started",target:"_blank",rel:"noopener noreferrer"},X=s('<p>第三步，运行<code>npx jest --init</code>命令，生成一份jest的配置文件<code>jest.config.js</code>,我的选择如下</p><img width="676" height="69" src="'+o+`" class="jop-noMdConv"><p>第四步，运行<code>npm i babel-jest @babel/core @babel/preset-env -D</code>安装<code>babel</code>，并且配置<code>.babelrc</code>如下</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
  presets: [
    [
      &#39;@babel/preset-env&#39;,
      {
        targets: {
          node: &#39;current&#39;,
        },
      },
    ],
  ],
};
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第五步，根目录下建立<code>src</code>文件夹，新建两个文件<code>basic.js</code>和<code>basic.test.js</code></p><p>第六步，<code>package.json</code>增加一条命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> &quot;scripts&quot;: {
    &quot;test&quot;: &quot;jest&quot;
  },
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上六步完成后，我们的项目结构应该如下图</p><p><img src="`+r+`" alt=""></p><h3 id="_4-2-最基本的jest用法" tabindex="-1"><a class="header-anchor" href="#_4-2-最基本的jest用法" aria-hidden="true">#</a> 4.2 最基本的<code>jest</code>用法</h3><p>接下来我们采用<code>TDD</code>加单元测试的方式来学习jest基本用法：</p><p>首先，在<code>basic.js</code>里定义两个工具函数</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 1. 寻找最大值
export function findMax (arr) {
    
}

// 2. 给定一个整数数组 nums 和一个目标值 target，在该数组中找出和为目标值的那 两个 整数，如果存在，返回true，否则返回false
export function twoSum (nums, target) {

};
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>既然是<code>TDD</code>，我们首先编写测试代码，在这个过程中，我们逐步学习各种<code>jest</code>的基本用法。测试代码在<code>basic.test.js</code>文件中编写：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import { findMax, twoSum } from &#39;./basic&#39;

// 期望findMax([2, 6, 3])执行后结果为6
test(&#39;findMax([2, 6, 3])&#39;, () =&gt; {
    expect(findMax([2, 6, 3])).toBe(6)
})

// 期望twoSum([2, 3, 4, 6], 10)执行后结果为true
test(&#39;twoSum([2, 3, 4, 6], 10)&#39;, () =&gt; {
    expect(twoSum([2, 3, 4, 6], 10)).toBe(true)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面代码，我们可以看到，<code>jest</code>测试代码的写法，和之前我们自己写的是一样的（当然啦，本来就是模仿<code>jest</code>的）,此时我们运行<code>npm test</code>命令，观察命令行输出如下：</p><img width="676" height="895" src="`+v+`" class="jop-noMdConv"><p>注意我红框里的部分，<code>Expected</code>代表期望函数执行的结果，也就是<code>toBe</code>里的那个值，<code>Received</code>代表实际执行函数得到的结果，因为我们还没有编写业务代码，所以<code>Received</code>都是<code>undefined</code>，最后显示一共<code>1</code>个测试文件（<code>Test Suites</code>）和<code>2</code>条测试代码，它们都测试失败了。</p><p>接下来我们完善<code>basic.js</code>里的逻辑</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 1. 寻找最大值
export function findMax (arr) {
    return Math.max(...arr)
}

// 2. 给定一个整数数组 nums 和一个目标值 target，在该数组中找出和为目标值的那 两个 整数，如果存在，返回true，否则返回false
export function twoSum (nums, target) {
    for (let i = 0; i &lt; nums.length - 1; i++) {
       for (let j = i + 1; j &lt; nums.length; j++) {
           if (nums[i] + nums[j] === target) {
               return true
           }
       } 
    }
    return false
};
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们再次运行<code>npm test</code>，得到结果如下</p><img width="676" height="248" src="`+u+`" class="jop-noMdConv"><p>我们可以看到，所有测试用例都通过了（直观的就是都绿了）。这种首先所有测试用例都没有通过（一片红），随着我们开发过程的进行，一步步的，最终测试代码都通过（一片绿）的过程，就是<code>TDD</code>和单元测试的开发过程。</p><h3 id="_4-3-更多的jest-matchers" tabindex="-1"><a class="header-anchor" href="#_4-3-更多的jest-matchers" aria-hidden="true">#</a> 4.3 更多的<code>jest</code> <code>matchers</code></h3><p>像是上小节，在<code>expect</code>函数后面跟着的判断结果的<code>toBe</code>在<code>jest</code>中被称为<code>matcher</code>，我们这一小节就来介绍另外一些常用的<code>matchers</code></p><h4 id="_4-3-1-toequal" tabindex="-1"><a class="header-anchor" href="#_4-3-1-toequal" aria-hidden="true">#</a> 4.3.1 <code>toEqual</code></h4><p>我们首先改造下刚刚的<code>twoSum</code>函数，让它返回找到的两个数的索引数组（<code>leetcode</code>第一题）</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 2. 给定一个整数数组 nums 和一个目标值 target，在该数组中找出和为目标值的那 两个 整数，
// 并返回他们的数组下标（假设每种输入只会对应一个答案，数组中同一个元素不能使用两遍）。
export function twoSum (nums, target) {
    for (let i = 0; i &lt; nums.length - 1; i++) {
       for (let j = i + 1; j &lt; nums.length; j++) {
           if (nums[i] + nums[j] === target) {
               return [i, j]
           }
       } 
    }
    return []
};
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来测试代码部分我们只保留对<code>twoSum</code>函数的测试，并同步修改测试代码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;twoSum([2, 3, 4, 6], 10)&#39;, () =&gt; {
    expect(twoSum([2, 3, 4, 6], 10)).toBe([2, 3])
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的期望是函数执行的结果是<code>[2, 3]</code>这样的数组，看起来没问题，运行<code>npm test</code></p><img width="676" height="409" src="`+m+`" class="jop-noMdConv"><p>我们发现并没有通过测试，这是因为，<code>toBe</code>可以判断基本类型数据，但是对于数组，对象这样的引用类型是没办法判断的，这个时候，我们就需要使用<code>toEqual</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;twoSum([2, 3, 4, 6], 10)&#39;, () =&gt; {
    expect(twoSum([2, 3, 4, 6], 10)).toEqual([2, 3])
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改成<code>toEqual</code>之后，测试代码就成功了</p><img width="676" height="221" src="`+b+`" class="jop-noMdConv"><h4 id="_4-3-2-判断逻辑真假相关的一些matchers" tabindex="-1"><a class="header-anchor" href="#_4-3-2-判断逻辑真假相关的一些matchers" aria-hidden="true">#</a> 4.3.2 判断逻辑真假相关的一些<code>matchers</code></h4><p>这部分内容很简单，也比较多，所以直接在代码里注释说明：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;变量a是否为null&#39;, () =&gt; {
    const a = null
    expect(a).toBeNull()
})

test(&#39;变量a是否为undefined&#39;, () =&gt; {
    const a = undefined
    expect(a).toBeUndefined()
})

test(&#39;变量a是否为defined&#39;, () =&gt; {
    const a = null
    expect(a).toBeDefined()
})

test(&#39;变量a是否为true&#39;, () =&gt; {
    const a = 1
    expect(a).toBeTruthy()
})

test(&#39;变量a是否为false&#39;, () =&gt; {
    const a = 0
    expect(a).toBeFalsy()
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果如下：</p><p><img src="`+p+`" alt=""></p><h4 id="_4-3-3-not修饰符" tabindex="-1"><a class="header-anchor" href="#_4-3-3-not修饰符" aria-hidden="true">#</a> 4.3.3 <code>not</code>修饰符</h4><p>很简单，<code>not</code>就是对<code>matcher</code>的否定</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;test not&#39;, () =&gt; {
    const temp = 10
    expect(temp).not.toBe(11)
    expect(temp).not.toBeFalsy()
    expect(temp).toBeTruthy()
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果如下：</p><p><img src="`+h+`" alt=""></p><h4 id="_4-3-4-判断数字相关的一些matchers" tabindex="-1"><a class="header-anchor" href="#_4-3-4-判断数字相关的一些matchers" aria-hidden="true">#</a> 4.3.4 判断数字相关的一些<code>matchers</code></h4><p>这部分内容很简单，也比较多，所以直接在代码里注释说明：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 判断数num是否大于某个数
test(&#39;toBeGreaterThan&#39;, () =&gt; {
    const num = 10
    expect(num).toBeGreaterThan(7)
})

// 判断数num是否大于等于某个数
test(&#39;toBeGreaterThanOrEqual&#39;, () =&gt; {
    const num = 10
    expect(num).toBeGreaterThanOrEqual(10)
})

// 判断数num是否小于某个数
test(&#39;toBeLessThan&#39;, () =&gt; {
    const num = 10
    expect(num).toBeLessThan(20)
})

// 判断数num是否小于等于某个数
test(&#39;toBeLessThanOrEqual&#39;, () =&gt; {
    const num = 10
    expect(num).toBeLessThanOrEqual(10)
    expect(num).toBeLessThanOrEqual(20)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果如下：</p><p><img src="`+g+`" alt=""></p><p>上面介绍的都是整数判断，十分简单，但是如果是浮点数相关的判断，会不太一样，比如，我们知道<code>0.1 + 0.2 = 0.3</code>这个式子在数学中没有问题，但是在计算机中，由于精度问题，这个<code>0.1 + 0.2</code>结果如果用<code>toBe</code>结果并不是准确的<code>0.3</code>，如果我们想要判断浮点数的相等，在<code>jest</code>中提供了一个<code>toBeCloseTo</code>的<code>matcher</code>可以解决：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;toBe&#39;, () =&gt; {
    const sum = 0.1 + 0.2
    expect(sum).toBe(0.3)
})

test(&#39;toBeCloseTo&#39;, () =&gt; {
    const sum = 0.1 + 0.2
    expect(sum).toBeCloseTo(0.3)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的测试结果如下：</p><img width="676" height="565" src="`+x+`" class="jop-noMdConv"><h4 id="_4-3-5-字符串匹配tomatch" tabindex="-1"><a class="header-anchor" href="#_4-3-5-字符串匹配tomatch" aria-hidden="true">#</a> 4.3.5 字符串匹配<code>toMatch</code></h4><p>这个<code>matcher</code>就是用来判断字符串是否和<code>toMatch</code>提供的模式匹配，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 字符串相关
test(&#39;toMatch&#39;, () =&gt; {
    const str = &#39;Lebron James&#39;
    expect(str).toMatch(/Ja/)
    expect(str).toMatch(&#39;Ja&#39;)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+f+`" alt=""></p><h4 id="_4-3-6-数组-集合相关的matchers" tabindex="-1"><a class="header-anchor" href="#_4-3-6-数组-集合相关的matchers" aria-hidden="true">#</a> 4.3.6 数组，集合相关的<code>matchers</code></h4><p>可以使用<code>toContain</code>判断数组或者集合是否包含某个元素，使用<code>toHaveLength</code>判断数组的长度，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;Array Set matchers&#39;, () =&gt; {
    const arr = [&#39;Kobe&#39;, &#39;James&#39;, &#39;Curry&#39;]
    const set = new Set(arr)
    expect(arr).toContain(&#39;Kobe&#39;)
    expect(set).toContain(&#39;Curry&#39;)
    expect(arr).toHaveLength(3)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="192" src="`+_+`" class="jop-noMdConv"><h4 id="_4-3-7-异常相关的matchers" tabindex="-1"><a class="header-anchor" href="#_4-3-7-异常相关的matchers" aria-hidden="true">#</a> 4.3.7 异常相关的<code>matchers</code></h4><p>使用<code>toThrow</code>来判断抛出的异常是否符合预期：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function throwError () {
    throw new Error(&#39;this is an error!!&#39;)
}
test(&#39;toThrow&#39;, () =&gt; {
    expect(throwError).toThrow(/this is an error/)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="213" src="`+j+`" class="jop-noMdConv"><h2 id="_5-jest进阶用法" tabindex="-1"><a class="header-anchor" href="#_5-jest进阶用法" aria-hidden="true">#</a> 5. <code>jest</code>进阶用法</h2><h3 id="_5-1-分组测试与勾子函数" tabindex="-1"><a class="header-anchor" href="#_5-1-分组测试与勾子函数" aria-hidden="true">#</a> 5.1 分组测试与勾子函数</h3><p>所谓分组测试，核心在于，将不同的测试进行分组，再结合勾子函数（生命周期函数），完成不同分组的定制化测试，以满足测试过程重的复杂需求。</p><p>我们首先在<code>src</code>下新建两个文件<code>hook.js</code>和<code>hook.test.js</code>，这一部分代码在这两个文件中完成，首先直接给出<code>hook.js</code>代码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// hook.js
export default class Count {
    constructor () {
        this.count = 2
    }
    increase () {
        this.count ++
    }

    decrease () {
        this.count --
    }

    double () {
        this.count *= this.count
    }

    half () {
        this.count /= this.count
    }
} 
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在呢，我们想要对<code>Count</code>类的四个方法单独测试，数据互相不影响，当然我们可以自己去直接实例化<code>4</code>个对象，不过，<code>jest</code>给了我们更优雅的写法---分组，我们使用<code>describe</code>函数分组，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>describe(&#39;分别测试Count的4个方法&#39;, () =&gt; {
    test(&#39;测试increase&#39;, () =&gt; {
        
    })
    test(&#39;测试decrease&#39;, () =&gt; {
        
    })
    test(&#39;测试double&#39;, () =&gt; {
        
    })
    test(&#39;测试half&#39;, () =&gt; {
        
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就使用<code>describe</code>函数配合<code>test</code>将测试分为了四组，接下来，为了能更好的控制每个<code>test</code>组，我们就要用到<code>jest</code>的勾子函数。 我们这里要介绍的是<code>jest</code>里的四个勾子函数<code>beforeEach,beforeAll,afterEach,afterAll</code>。</p><p>顾名思义，<code>beforeEach</code>是在每一个test函数执行之前，会被调用；<code>afterEach</code>则是在每一个test函数执行之后调用；<code>beforeAll</code>是在所有test函数执行之前调用；<code>afterAll</code>则是在所有test函数执行之后调用。我们可以看下面这个例子：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import Count from &quot;./hook&quot;

describe(&#39;分别测试Count的4个方法&#39;, () =&gt; {
    let count
    beforeAll(() =&gt; {
        console.log(&#39;before all tests!&#39;)
    })

    beforeEach(() =&gt; {
        console.log(&#39;before each test!&#39;)
        count = new Count()
    })

    afterAll(() =&gt; {
        console.log(&#39;after all tests!&#39;)
    })

    afterEach(() =&gt; {
        console.log(&#39;after each test!&#39;)
    })

    test(&#39;测试increase&#39;, () =&gt; {
        count.increase()
        console.log(count.count)
    })
    test(&#39;测试decrease&#39;, () =&gt; {
        count.decrease()
        console.log(count.count)
    })
    test(&#39;测试double&#39;, () =&gt; {
        count.double()
        console.log(count.count)
    })
    test(&#39;测试half&#39;, () =&gt; {
        count.half()
        console.log(count.count)
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的结果如图：</p><img width="676" height="1419" src="`+q+`" class="jop-noMdConv"><p>可以看到，我们在每个test执行之前，<code>beforeEach</code>里面重新实例化了<code>count</code>，所以每一次的count是不同的。合理的使用勾子函数，我们可以更好的定制测试。</p><h3 id="_5-2-异步代码测试之定时器" tabindex="-1"><a class="header-anchor" href="#_5-2-异步代码测试之定时器" aria-hidden="true">#</a> 5.2 异步代码测试之定时器</h3><p>在我们前端开发过程中，由于<code>javascript</code>是单线程的，异步编程是我们开发人员经常要做的工作，而异步代码也是最容易出错的地方，对异步代码逻辑进行测试，是很有必要的，这一节将对<code>jest</code>如何进行异步测试，做一个详细的介绍。</p><h4 id="_5-2-1-从最简单的settimeout开始" tabindex="-1"><a class="header-anchor" href="#_5-2-1-从最简单的settimeout开始" aria-hidden="true">#</a> 5.2.1 从最简单的<code>setTimeout</code>开始</h4><p>我们首先新建<code>timeout.js，timeout.test.js</code>文件，<code>timeout.js</code>文件代码很简单：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export default (fn) =&gt; {
    setTimeout(() =&gt; {
       fn()
    }, 2000)
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们现在的目标就是去测试，写的这个函数，是不是会像我们预期的那样，传入一个函数作为参数（简单为主，没有做参数校验），<code>2s</code>后，执行这个函数。</p><p>我们的测试代码（<code>timeout.test.js</code>）如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import timeout from &#39;./timeout&#39;

test(&#39;测试timer&#39;, () =&gt; {
    timeout(() =&gt; {
        expect(2+2).toBe(4)
    })
})

复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们运行这段测试代码，一定是会通过的，但是，这真的代表我们写在<code>timeout</code>里的方法测试通过了吗？我们在<code>timout.js</code>中打印输出一段文字</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export default (fn) =&gt; {
    setTimeout(() =&gt; {
       fn(

)
       console.log(&#39;this is timeout!&#39;)
    }, 2000)
} 复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们运行测试代码（<code>npm test timeout.test</code>这样只运行一个文件），你会发现，什么打印内容都没有输出：</p><img width="676" height="192" src="`+w+`" class="jop-noMdConv"><p>其实产生这种现象的原因也很简单，<code>jest</code>在运行测试代码，执行<code>test</code>方法时，从函数内部第一行执行到最后一行，当执行逻辑走到代码块最后一行时，没有异常就会返回测试成功，这个过程中<code>不会去等待异步代码的执行结果</code>，所以我们这样的测试方法，不管<code>setTimeout</code>里怎么实现，回调函数里怎么实现，都不会执行回调函数内部的逻辑。</p><p>如果我们需要测试代码在真正执行了定时器里的异步逻辑后，才返回测试结果，我们需要给<code>test</code>方法的回调函数传入一个<code>done</code>参数，并在<code>test</code>方法内异步执行的代码中调用这个<code>done</code>方法，这样，<code>test</code>方法会等到<code>done</code>所在的代码块内容执行完毕后才返回测试结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import timeout from &#39;./timeout&#39;

test(&#39;测试timer&#39;, (done) =&gt; {
    timeout(() =&gt; {
        expect(2+2).toBe(4)
        done()
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="356" src="`+k+`" class="jop-noMdConv"><p>我们可以看到，增加<code>done</code>参数之后，得到了预期的结果，打印输出了内容，证明我们回调函数内的代码执行了。</p><h4 id="_5-2-2-使用faketimers提高测试效率" tabindex="-1"><a class="header-anchor" href="#_5-2-2-使用faketimers提高测试效率" aria-hidden="true">#</a> 5.2.2 使用<code>fakeTimers</code>提高测试效率</h4><p>我们上一小节介绍了如何去测试写在定时器里异步代码的执行，但这里存在一个问题，比如，我们的定时器可能需要几十秒才执行内部逻辑（这虽然很少见，主要看业务需求），我们的测试代码也会很久才会返回结果，这无疑大大的降低了开发测试效率。</p><p><code>jest</code>也考虑到了这一点，让我们可以使用<code>fakeTimers</code>模拟真实的定时器。这个<code>fakeTimers</code>在遇到定时器时，允许我们立即跳过定时器等待时间，执行内部逻辑，比如，对于刚刚的<code>timeout.test</code>，我们的测试代码可以做如下改变：</p><ol><li>首先，我们使用<code>jest.fn()</code>生成一个<code>jest</code>提供的用来测试的函数，这样我们之后回调函数不需要自己去写一个</li><li>其次，我们使用<code>jest.useFakeTimers()</code>方法启动<code>fakeTimers</code></li><li>最后，我们可以通过<code>jest.advanceTimersByTime()</code>方法，参数传入毫秒时间，<code>jest</code>会立即跳过这个时间值，还可以通过<code>toHaveBeenCalledTimes()</code>这个<code>mathcer</code>来测试函数的调用次数。</li></ol><p>完整代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试timer&#39;, () =&gt; {
    jest.useFakeTimers()
    const fn = jest.fn()
    timeout(fn)
    // 时间快进2秒
    jest.advanceTimersByTime(2000)
    expect(fn).toHaveBeenCalledTimes(1)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="346" src="`+T+`" class="jop-noMdConv"><p>我们依然获得了预期的测试结果，注意观察输出结果里<code>测试timer(12ms)</code>对比之前的<code>测试timer(2021ms)</code>，可以看到，定时器的延迟时间，确实被跳过了，这提高了测试开发效率。</p><h4 id="_5-2-3-更复杂的定时器场景" tabindex="-1"><a class="header-anchor" href="#_5-2-3-更复杂的定时器场景" aria-hidden="true">#</a> 5.2.3 更复杂的定时器场景</h4><p>经过前面两节的介绍，对于定时器这种异步场景的测试代码编写，实际上我们已经掌握核心内容，这一节，我们去探讨一个更为复杂的场景，那就是定时器嵌套。</p><p>我们首先改造<code>timout</code>里的代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export default (fn) =&gt; {
    setTimeout(() =&gt; {
       fn(

)
       console.log(&#39;this is timeout outside!&#39;)
       setTimeout((

) =&gt; {
            fn(

)
           console.log(&#39;this is timeout inside!&#39;)
       }, 3000)
    }, 2000)
} 复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照上一小节的写法，我们的测试代码可以改造为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试timer&#39;, () =&gt; {
    jest.useFakeTimers()
    const fn = jest.fn()
    timeout(fn)
    // 时间快进2秒
    jest.advanceTimersByTime(2000)
    expect(fn).toHaveBeenCalledTimes(1)
    // 时间快进3秒
    jest.advanceTimersByTime(3000)
    expect(fn).toHaveBeenCalledTimes(2)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实也很简单，就是在第一次<code>2s</code>后，再过<code>3s</code>后执行第二个定时器，此时<code>fn</code>被调用了<code>2</code>次，所以我们只需要加上最后两行代码就可以了。执行结果如下：</p><img width="676" height="439" src="`+B+`" class="jop-noMdConv"><p>我们可以看到，两条打印结果都输出了。但是目前的这种实现不是很好，试想一下，如果这里面的定时器嵌套比较多，或者我们不清楚有几个定时器，就会比较麻烦。<code>jest</code>为这种情况提供了两个有用的方法：</p><ol><li><code>jest.runAllTimers()</code></li></ol><p>这个方法就如同它的名字一样，调用之后，会执行所有定时器，我们的代码可以改造如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试timer&#39;, () =&gt; {
    jest.useFakeTimers()
    const fn = jest.fn()
    timeout(fn)
    jest.runAllTimers()
    expect(fn).toHaveBeenCalledTimes(2)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="440" src="`+C+`" class="jop-noMdConv"><p>可以看到，两个定时器内部的打印都输出了，而且<code>jest</code>依旧快速的跳过了定时器等待时间。</p><ol start="2"><li><code>jest.runOnlyPendingTimers()</code></li></ol><p>这个方法的意思是，只执行当前正在等待的所有定时器，这个例子中，只有外层定时器是正在等待的，内层定时器只有在外层定时器执行时，才处于等待状态，我们改造测试代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试timer&#39;, () =&gt; {
    jest.useFakeTimers()
    const fn = jest.fn()
    timeout(fn)
    jest.runOnlyPendingTimers()
    expect(fn).toHaveBeenCalledTimes(1)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="417" src="`+M+`" class="jop-noMdConv"><p>可以看到，只有外层定时器里的内容被打印输出了。如果我们想要继续输出内部定时器的内容，因为此时内部定时器处于等待状态，所以再次执行<code>jest.runOnlyPendingTimers()</code>即可。</p><p><code>关于上述内容，有一点需要说明：</code></p><p>如果我们编写了多个<code>test</code>函数，它们都使用<code>fakeTimers</code>，一定要在<code>beforeEach</code>勾子中每次都调用<code>jest.useFakeTimers()</code>，否则，多个<code>test</code>函数中的<code>fakeTimers</code>会是同一个，将会互相干扰，产生不符合预期的执行结果</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>beforeEach(() =&gt; {
    jest.useFakeTimers()
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-3-异步代码测试之数据请求-promise-async-await" tabindex="-1"><a class="header-anchor" href="#_5-3-异步代码测试之数据请求-promise-async-await" aria-hidden="true">#</a> 5.3 异步代码测试之数据请求<code>(promise/async await)</code></h3><h4 id="_5-3-1-传统的promise写法" tabindex="-1"><a class="header-anchor" href="#_5-3-1-传统的promise写法" aria-hidden="true">#</a> 5.3.1 传统的<code>promise</code>写法</h4><p>在我们前端开发中，通过请求后端接口获取数据是很重要的一个流程，这一节主要就是介绍这个过程中如何编写测试代码（实际上这里的很多内容，之前介绍定时器的章节是有介绍过的）</p><p>为了简单起见，我们使用<code>axios(npm i axios)</code>这个成熟的库来辅助我们做数据请求。首先新建<code>request.js, request.test.js</code>这两个文件，在<code>request.js</code>文件请求一个免费api:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import axios from &#39;axios&#39;

export const request = fn =&gt; {
    axios.get(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;).then(res =&gt; {
        fn(res)
        console.log(res)
    })
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在<code>request.test.js</code>中，为了保证异步代码执行完毕后结束测试，和之前介绍的一样，在<code>test</code>的回调函数中传入<code>done</code>参数，在回调函数里执行<code>done()</code>，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import { request } from &#39;./request&#39;

test(&#39;测试request&#39;, (done) =&gt; {
    request(data =&gt; {
        expect(data.data).toEqual({
            &quot;userId&quot;: 1,
            &quot;id&quot;: 1,
            &quot;title&quot;: &quot;delectus aut autem&quot;,
            &quot;completed&quot;: false
          })
        done()
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="666" src="`+E+`" class="jop-noMdConv"><p>我们可以看到，打印出了请求回来的内容，测试代码也正确的拿到数据，测试通过。</p><p>我们现在改造一下<code>request.js</code>的代码，让它返回一个<code>promise</code>:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export const request = () =&gt; {
    return axios.get(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;)
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了测试上述代码，我们<code>request.test.js</code>也要做一定的修改：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试request&#39;, () =&gt; {
    return request().then(data =&gt; {
        expect(data.data).toEqual({
            &quot;userId&quot;: 1,
            &quot;id&quot;: 1,
            &quot;title&quot;: &quot;delectus aut autem&quot;,
            &quot;completed&quot;: false
          })
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，上面的写法不需要传入<code>done</code>参数了，但是，需要我们使用<code>return</code>返回，如果不写<code>return</code>，那<code>jest</code>执行<code>test</code>函数时，将不会等待<code>promise</code>返回，这样的话，测试结果输出时，<code>then</code>方法将不会执行。我们可以尝试以下两种写法（改变<code>&quot;completed&quot;: true</code>），第一种写法测试不会通过，第二种测试是可以通过的（因为promise并没有返回结果）:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 第一种
test(&#39;测试request&#39;, () =&gt; {
    return request().then(data =&gt; {
        expect(data.data).toEqual({
            &quot;userId&quot;: 1,
            &quot;id&quot;: 1,
            &quot;title&quot;: &quot;delectus aut autem&quot;,
            &quot;completed&quot;: true
          })
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="711" src="`+y+`" class="jop-noMdConv"><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 第二种
test(&#39;测试request&#39;, () =&gt; {
    request().then(data =&gt; {
        expect(data.data).toEqual({
            &quot;userId&quot;: 1,
            &quot;id&quot;: 1,
            &quot;title&quot;: &quot;delectus aut autem&quot;,
            &quot;completed&quot;: true
          })
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+D+`" alt=""></p><p>上面的测试代码，我们也可以写成下面的形式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试request&#39;, () =&gt; {
    return expect(request()).resolves.toMatchObject({
        data: {
            &quot;userId&quot;: 1,
            &quot;id&quot;: 1,
            &quot;title&quot;: &quot;delectus aut autem&quot;,
            &quot;completed&quot;: false
          }
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>resolves</code>将返回<code>request</code>方法执行后所有返回内容，我们使用<code>toMatchObject</code>这个<code>matcher</code>，当传入的对象能够匹配到<code>request</code>方法执行后返回对象的一部分键值对，测试就会通过。</p><h4 id="_5-3-2-使用async-await语法糖" tabindex="-1"><a class="header-anchor" href="#_5-3-2-使用async-await语法糖" aria-hidden="true">#</a> 5.3.2 使用<code>async await</code>语法糖</h4><p><code>async await</code>本质上就是<code>promise</code>链式调用的语法糖，我们上一小节最后的测试代码，如果使用<code>async await</code>的方式去书写，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 写法一
test(&#39;测试request&#39;, async () =&gt; {
    const res = await request()
    expect(res.data).toEqual({
        &quot;userId&quot;: 1,
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;delectus aut autem&quot;,
        &quot;completed&quot;: false
    })
})
// 写法二
test(&#39;测试request&#39;, async () =&gt; {
    await expect(request()).resolves.toMatchObject({
        data: {
            &quot;userId&quot;: 1,
            &quot;id&quot;: 1,
            &quot;title&quot;: &quot;delectus aut autem&quot;,
            &quot;completed&quot;: false
            }
        })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="242" src="`+F+`" class="jop-noMdConv"><p>我们上述两种写法都是可以通过测试的。</p><h4 id="_5-3-3-对于请求出现错误的测试" tabindex="-1"><a class="header-anchor" href="#_5-3-3-对于请求出现错误的测试" aria-hidden="true">#</a> 5.3.3 对于请求出现错误的测试</h4><p>在我们实际项目中，需要对这种接口请求做错误处理，同样，也需要对异常情况编写测试代码。</p><p>我们首先在<code>request.js</code>增加一个方法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export const requestErr = fn =&gt; {
    return axios.get(&#39;https://jsonplaceholder.typicode.com/sda&#39;)
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里请求一个不存在的接口地址，会返回<code>404</code>，于是我们的的测试代码为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试request 404&#39;, () =&gt; {
    return requestErr().catch((e) =&gt; {
        console.log(e.toString())
        expect(e.toString().indexOf(&#39;404&#39;) &gt; -1).toBeTruthy()
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="272" src="`+S+'" class="jop-noMdConv"><p>这里有个地方需要注意一下，下图是<code>jest</code>官网的一段说明：</p><img width="676" height="449" src="'+O+'" class="jop-noMdConv"><p>大概意思就是说，如果测试代码里使用<code>catch</code>，jest不回去执行<code>catch</code>里的内容，所以需要我们去写<code>expect.assertions(1)</code>这句话，代表，期望执行的断言是1次，<code>catch</code>方法算一次断言，所以，正常情况，由于不会执行<code>catch</code>，这里会报错（执行了0次断言），当这里报错了，说明我们的代码也按照预期产生了异常。</p>',163),Y={href:"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fjest%2Fpull%2F7131",title:"https://github.com/facebook/jest/pull/7131",target:"_blank",rel:"noopener noreferrer"},Z=s(`<p>同样的，我们还可以使用另一种方式完成异常代码测试：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试request 404&#39;, () =&gt; {
    return expect(requestErr()).rejects.toThrow(/404/)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>rejects</code>和上一节的<code>resolves</code>相互对于，代表执行方法产生的错误对象，这个错误对象抛出<code>404</code>异常(<code>toThrow(/404/)</code>)</p><p>我们同样可以使用<code>async await</code>语法糖书写异常测试的代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试request 404&#39;, async () =&gt; {
    await expect(requestErr()).rejects.toThrow(/404/)
})
// 或者可以使用try catch语句写的更完整
test(&#39;测试request 404&#39;, async () =&gt; {
    try {
        await requestErr()
    } catch (e) {
        expect(e.toString()).toBe(&#39;Error: Request failed with status code 404&#39;)
    }
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-4-在测试中模拟-mock-数据" tabindex="-1"><a class="header-anchor" href="#_5-4-在测试中模拟-mock-数据" aria-hidden="true">#</a> 5.4 在测试中模拟（<code>mock</code>）数据</h3><p>我们首先新建<code>mock.js, mock.test.js</code>文件</p><h4 id="_5-4-1-使用jest-fn-模拟函数" tabindex="-1"><a class="header-anchor" href="#_5-4-1-使用jest-fn-模拟函数" aria-hidden="true">#</a> 5.4.1 使用<code>jest.fn()</code>模拟函数</h4><p>首先在<code>mock.js</code>写一个函数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export const run = fn =&gt; {
   return fn(&#39;this is run!&#39;)
} 复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上之前我们已经使用过<code>jest.fn()</code>了，这里我们更进一步的学习它。</p><ol><li>首先，我们的<code>fn()</code>函数可以接受一个函数作为参数，这个函数就是我们想要<code>jest.fn()</code>为我们<code>mock</code>的函数，我们编写<code>mock.test.js</code>：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试 jest.fn()&#39;, () =&gt; {
    const fn = jest.fn(() =&gt; {
        return &#39;this is mock fn 1&#39;
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>其次，<code>jest.fn()</code>可以初始化时候不传入参数，然后通过调用生成的<code>mock</code>函数的<code>mockImplementation</code>或者<code>mockImplementationOnce</code>方法来改变mock函数内容，这两个方法的区别是，<code>mockImplementationOnce</code>只会改变要<code>mock</code>的函数一次：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试 jest.fn()&#39;, () =&gt; {
    const func = jest.fn()
    func.mockImplementation(() =&gt; {
        return &#39;this is mock fn 1&#39;
    })
    func.mockImplementationOnce(() =&gt; {
        return &#39;this is mock fn 2&#39;
    })
    const a = run(func)
    const b = run(func)
    const c = run(func)
    console.log(a)
    console.log(b)
    console.log(c)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="448" src="`+I+`" class="jop-noMdConv"><p>我们可以看到，函数执行的结果第一次是<code>this is mock fn 2</code>，之后都是<code>this is mock fn 1</code></p><p>同样的，我们可以使用<code>mock</code>函数的<code>mockReturnValue</code>和<code>mockReturnValueOnce（一次）</code>方法来改变函数的返回值：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试 jest.fn()&#39;, () =&gt; {
    const func = jest.fn()
    func.mockImplementation(() =&gt; {
        return &#39;this is mock fn 1&#39;
    })
    func.mockImplementationOnce(() =&gt; {
        return &#39;this is mock fn 2&#39;
    })
    func.mockReturnValue(&#39;this is mock fn 3&#39;)
    func.mockReturnValueOnce(&#39;this is mock fn 4&#39;)
        .mockReturnValueOnce(&#39;this is mock fn 5&#39;)
        .mockReturnValueOnce(&#39;this is mock fn 6&#39;)
    const a = run(func)
    const b = run(func)
    const c = run(func)
    const d = run(func)
    console.log(a)
    console.log(b)
    console.log(c)
    console.log(d)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="491" src="`+V+`" class="jop-noMdConv"><p>注意到，方法是可以链式调用的，方便多次输出不同的返回值。</p><ol start="3"><li>最后，我们可以使用<code>toBeCalledWith</code>这个<code>matcher</code>来测试函数的传参数是否符合预期：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;测试 jest.fn()&#39;, () =&gt; {
    const func = jest.fn()
    const a = run(func)
    expect(func).toBeCalledWith(&#39;this is run!&#39;)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="226" src="`+A+`" class="jop-noMdConv"><h4 id="_5-4-2-模拟接口中获取的数据" tabindex="-1"><a class="header-anchor" href="#_5-4-2-模拟接口中获取的数据" aria-hidden="true">#</a> 5.4.2 模拟接口中获取的数据</h4><p>很多时候，我们在前端开发过程中，后端接口还没有提供，我们需要去<code>mock</code>接口返回的数据。</p><p>我们首先在<code>mock.js</code>中编写一个简单的请求数据的代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import axios from &#39;axios&#39;

export const request = fn =&gt; {
    return axios.get(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;)
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，我们在<code>mock.test.js</code>中，使用<code>jest.mock()</code>方法模拟<code>axios</code>，使用<code>mockResolvedValue</code>和<code>mockResolvedValueOnce</code>方法模拟返回的数据，同样的，<code>mockResolvedValueOnce</code>方法只会改变一次返回的数据：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import axios from &#39;axios&#39;
import { request } from &#39;./mock&#39;

jest.mock(&#39;axios&#39;)

test(&#39;测试request&#39;, async () =&gt; {
    axios.get.mockResolvedValueOnce({ data: &#39;Jordan&#39;, position: &#39;SG&#39; })
    axios.get.mockResolvedValue({ data: &#39;kobe&#39;, position: &#39;SG&#39; })
    await request().then((res) =&gt; {
        expect(res.data).toBe(&#39;Jordan&#39;)
    })
    await request().then((res) =&gt; {
        expect(res.data).toBe(&#39;kobe&#39;)
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="231" src="`+R+`" class="jop-noMdConv"><p>我们使用<code>jest.mock(&#39;axios&#39;)</code>来使用<code>jest</code>去模拟<code>axios</code>，测试正确的通过了。</p><h3 id="_5-5-dom相关测试" tabindex="-1"><a class="header-anchor" href="#_5-5-dom相关测试" aria-hidden="true">#</a> 5.5 <code>dom</code>相关测试</h3><p><code>dom</code>相关的测试其实很简单，我们首先新建<code>dom.js, dom.test.js</code>两个文件，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// dom.js
export const generateDiv = (

) =&gt; {
    const div = document.createElement(&#39;div&#39;)
    div.className = &#39;test-div&#39;
    document.body.appendChild(div)
}

// dom.test.js
import { generateDiv } from &#39;./dom&#39;

test(&#39;测试dom操作&#39;, () =&gt; {
    generateDiv()
    generateDiv()
    generateDiv()
    expect(document.getElementsByClassName(&#39;test-div&#39;).length).toBe(3)
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img width="676" height="228" src="`+L+`" class="jop-noMdConv"><p>这里只有一点要说明，<code>jest</code>的运行环境是<code>node.js</code>，这里<code>jest</code>使用<code>jsdom</code>来让我们可以书写<code>dom</code>操作相关的测试逻辑。</p><h3 id="_5-6-快照-snapshot-测试" tabindex="-1"><a class="header-anchor" href="#_5-6-快照-snapshot-测试" aria-hidden="true">#</a> 5.6 快照（<code>snapshot</code>）测试</h3><p>我们如果没有接触过快照测试，可能会觉得这个名字很高大上。所以我们首先新建<code>snapshot.js, shapshot.test.js</code>来看看快照测试究竟是什么。</p><p>在我们的日常开发中，总会写一些配置性的代码，它们大体不会变化，但是也会有小的变更，这样的配置可能如下（<code>snapshot.js</code>）:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export const getConfig = (

) =&gt; {
    return {
        server: &#39;https://demo.com&#39;,
        port: &#39;8080&#39;
    }
}
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的测试代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import { getConfig } from &#39;./snapshot&#39;

test(&#39;getConfig测试&#39;, () =&gt; {
    expect(getConfig()).toEqual({
        server: &#39;https://demo.com&#39;,
        port: &#39;8080&#39;
    })
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们通过了测试。但是，假如后续我们的配置改变了，我就需要同步的去修改测试代码，这样会比较麻烦，从而，<code>jest</code>为我们引入了快照测试，先上测试代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>test(&#39;getConfig测试&#39;, () =&gt; {
    expect(getConfig()).toMatchSnapshot()
})
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们运行测试代码之后，会在项目根目录下生成一个<code>__snapshots__</code>文件夹，下面有一个<code>snapshot.test.js.snap</code>快照文件，文件内容如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[\`getConfig测试 1\`] = \`
Object {
  &quot;port&quot;: &quot;8080&quot;,
  &quot;server&quot;: &quot;https://demo.com&quot;,
}
\`;
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>jest</code>会在运行<code>toMatchSnapshot()</code>的时候，首先检查有没有这个快照文件，如果没有，则生成，当我们改动配置内容时，比如把<code>port</code>改为<code>8090</code>，再次运行测试代码，测试不通过，结果如下：</p><img width="676" height="458" src="`+J+'" class="jop-noMdConv"><p>这个时候，我们只需要运行<code>npm test snapshot.test -- -u</code>，就可以自动更新我们的快照文件，测试再次通过，这就让我们不需要每次更改配置文件的时候，手动去同步更新测试代码，提高了测试开发效率：</p><img width="676" height="270" src="'+N+`" class="jop-noMdConv"><p>此时我们的快照文件更新为如下代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[\`getConfig测试 1\`] = \`
Object {
  &quot;port&quot;: &quot;8090&quot;,
  &quot;server&quot;: &quot;https://demo.com&quot;,
}
\`;
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-jest其它一些有用的知识" tabindex="-1"><a class="header-anchor" href="#_6-jest其它一些有用的知识" aria-hidden="true">#</a> 6. <code>jest</code>其它一些有用的知识</h2><h3 id="_6-1-让jest监听文件变化" tabindex="-1"><a class="header-anchor" href="#_6-1-让jest监听文件变化" aria-hidden="true">#</a> 6.1 让<code>jest</code>监听文件变化</h3><p>这个功能很简单，我们只需要运行<code>jest</code>命令的时候，后面加上<code>--watch</code>即可，我们在<code>package.json</code>中新增一条命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&quot;scripts&quot;: {
    &quot;test&quot;: &quot;jest&quot;,
    &quot;test-watch&quot;: &quot;jest --watch&quot;
},
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在新增完这条命令后，为了能让<code>jest</code>可以监听文件变化，我们还需要把我们的代码文件变成一个<code>git</code>仓库，<code>jest</code>也正式依靠<code>git</code>的能力实现监听文件变化的，我们运行<code>git init</code>，接着我们运行<code>npm run test-watch</code>，在一定时间后，我们开启监听模式，命令行最后几行输出应该是：</p><img width="676" height="178" src="`+H+`" class="jop-noMdConv"><p>这里对<code>watch</code>模式的几个有用功能做一个简单介绍（也就是图中英文说明）：</p><ol><li>按<code>a</code>键运行所有测试代码</li><li>按<code>f</code>键只运行所有失败的测试代码</li><li>按<code>p</code>键按照文件名筛选测试代码（支持正则）</li><li>按<code>t</code>键按照测试名筛选测试代码（支持正则）</li><li>按<code>q</code>键盘推出<code>watch</code>模式</li><li>按<code>enter</code>键触发一次测试运行</li></ol><p>这些我建议大家自行去尝试，它们都是十分简单好用的功能。</p><h3 id="_6-2-生成测试覆盖率文件" tabindex="-1"><a class="header-anchor" href="#_6-2-生成测试覆盖率文件" aria-hidden="true">#</a> 6.2 生成测试覆盖率文件</h3><p>测试覆盖率，简单来说就是我们业务代码中，编写测试代码的比例，<code>jest</code>给我们提供了直接生成测试覆盖率文件的方法，也就是运行<code>jest</code>命令时后面加上<code>--coverage</code>参数，我们修改<code>package.json</code>文件如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&quot;scripts&quot;: {
    &quot;test&quot;: &quot;jest&quot;,
    &quot;test-watch&quot;: &quot;jest --watch&quot;,
    &quot;coverage&quot;: &quot;jest --coverage&quot;
},
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，运行<code>npm run coverage</code>，我们可以看到命令行输出如下：</p><img width="676" height="309" src="`+G+'" class="jop-noMdConv"><p>这是一份测试覆盖率表格。同时，我们发现，文件夹下自动生成了一个<code>coverage</code>文件夹:</p><p><img src="'+P+'" alt=""></p><p>我们在浏览器中运行<code>index.html</code>,如下图：</p><img width="676" height="198" src="'+z+'" class="jop-noMdConv"><p>这个页面向我们展示了项目中不同文件的测试覆盖率，我们可以点击不同文件名字进入查看具体一个文件中，哪些代码被测试到了，哪些没有被测试到。</p><p>这里对这个表格项目做一个简单的说明：</p><ol><li><p><code>Statements</code>是语句覆盖率：表示代码中有多少执行的语句被测试到了</p></li><li><p><code>Branches</code>是分支覆盖率：表示代码中有多少<code>if else switch</code>分支被测试到了</p></li><li><p><code>Functions</code>是函数覆盖率：表示代码中被测试到的函数的占比</p></li><li><p><code>Lines</code>是行覆盖率：表示代码中被测试到的行数占比</p></li></ol><p>我们可以利用生成的测试覆盖率文件，更好的完善改进我们的测试代码。</p><h3 id="_6-3-关于jest-config-js配置文件" tabindex="-1"><a class="header-anchor" href="#_6-3-关于jest-config-js配置文件" aria-hidden="true">#</a> 6.3 关于<code>jest.config.js</code>配置文件</h3><p>我对于学习一个工具的配置文件的建议是，首先按照默认的来，当你需要改变配置的时候，再去查阅官方文档学习，不推荐去死记硬背。</p>',77),ee=n("code",null,"jest",-1),ne=n("code",null,"jest.config.js",-1),ie={href:"https://link.juejin.cn?target=https%3A%2F%2Fjestjs.io%2Fdocs%2Fen%2Fconfiguration%23docsNav",title:"https://jestjs.io/docs/en/configuration#docsNav",target:"_blank",rel:"noopener noreferrer"},de=n("h2",{id:"_7-写在最后",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_7-写在最后","aria-hidden":"true"},"#"),e(" 7. 写在最后")],-1),se=n("code",null,"api",-1),ae={href:"https://link.juejin.cn?target=https%3A%2F%2Fjestjs.io%2Fen%2F",title:"https://jestjs.io/en/",target:"_blank",rel:"noopener noreferrer"},te=n("p",null,[e("这篇文章个人认为已经把"),n("code",null,"jest"),e("的基础和最核心的内容做了阐述，可能我们开发过程中，使用"),n("code",null,"react(enzyme), vue( @vue/test-utils)"),e("这样的开发框架，使用"),n("code",null,"webpack"),e("这样的工程化工具，在使用"),n("code",null,"jest"),e("的时候，会结合使用一些开源库，我相信学好了"),n("code",null,"jest"),e("本身之后，配置和使用它们都不会有太多困难。")],-1);function ce(le,oe){const i=t("ExternalLinkIcon");return c(),l("div",null,[Q,n("p",null,[e("第二步，安装"),W,e(),$,e("（安装可以参考"),n("a",U,[e("官网"),d(i)]),e("）")]),X,n("p",null,[e("这种写法目前已经不需要了，详细见"),n("a",Y,[e("removed useless expect.assertions"),d(i)]),e("，所以，现在就按照上面那种方式，直接书写，测试通过代表确实如我们预期的产生异常。")]),Z,n("p",null,[e("我这里也不会去介绍怎么去配置"),ee,e("文件，我们可以通过jest初始化时候默认生成的那个"),ne,e("来学习（有详细注释），也可以在"),n("a",ie,[e("官网"),d(i)]),e("中查阅相关的配置参数。")]),de,n("p",null,[e("由于篇幅原因，不适合再介绍更多的信息，更多的"),se,e("相关的信息，建议去查阅"),n("a",ae,[e("官网"),d(i)]),e("来学习。")]),te])}const ve=a(K,[["render",ce],["__file","qianduanceshizhiJestshenruqianchu.html.vue"]]);export{ve as default};
