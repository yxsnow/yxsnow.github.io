import{_ as p,o as a,c as i,a as e}from"./app-ff2f634e.js";const t={},o=e('<h2 id="_0-1-0-2-的计算过程计算过程" tabindex="-1"><a class="header-anchor" href="#_0-1-0-2-的计算过程计算过程" aria-hidden="true">#</a> 0.1+0.2 的计算过程计算过程</h2><h3 id="_1、十进制转成二进制" tabindex="-1"><a class="header-anchor" href="#_1、十进制转成二进制" aria-hidden="true">#</a> 1、十进制转成二进制</h3><p><strong>在JS内部所有的计算都是以二进制方式计算的。</strong> 所以运算 0.1+ 0.2 时要先把 0.1和 0.2 从十进制转成二进制。</p><ul><li><p>0.1转化成二进制的算法：</p><p>0.1*2=0.2======取出整数部分0</p><p>0.2*2=0.4======取出整数部分0</p><p>0.4*2=0.8======取出整数部分0</p><p>0.8*2=1.6======取出整数部分1</p><p>0.6*2=1.2======取出整数部分1</p><p>接下来会无限循环</p><p>0.2*2=0.4======取出整数部分0</p><p>0.4*2=0.8======取出整数部分0</p><p>0.8*2=1.6======取出整数部分1</p><p>0.6*2=1.2======取出整数部分1</p><p>所以0.1转化成二进制是：0.0001 1001 1001 1001…</p></li><li><p>0.2转化成二进制的算法：</p><p>0.2*2=0.4======取出整数部分0</p><p>0.4*2=0.8======取出整数部分0</p><p>0.8*2=1.6======取出整数部分1</p><p>0.6*2=1.2======取出整数部分1</p><p>接下来会无限循环</p><p>0.2*2=0.4======取出整数部分0</p><p>0.4*2=0.8======取出整数部分0</p><p>0.8*2=1.6======取出整数部分1</p><p>0.6*2=1.2======取出整数部分1</p><p>所以0.2转化成二进制是：0.0011 0011 0011 0011…</p></li></ul><p>这里要注意 0.1 和 0.2 转成的二进制是无穷的。另外<strong>在现代浏览器中是用浮点数形式的二进制来存储二进制，所以还要把上面所转化的二进制转成浮点数形式的二进制。</strong></p><h3 id="_2、转成浮点数" tabindex="-1"><a class="header-anchor" href="#_2、转成浮点数" aria-hidden="true">#</a> 2、转成浮点数</h3><p>浮点数分为单精度对应32位操作系统和双精度对应64位操作系统。目前的操作系统大多是64位操作系统，故这里只解释一下二进制如何转成双精度浮点数的二进制。</p><p>双精度浮点数用1位表示符号位，11位表示指数位，52位表示小数位，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-fd47c013b933a077?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp" alt=""></p><ul><li><p>符号位：正数为0，负数为1；</p></li><li><p>指数位：<code>阶数</code>+<code>偏移量</code>，阶数是：</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-b6e8bb46d9fb09eb?imageMogr2/auto-orient/strip|imageView2/2/w/63/format/webp" alt=""></p><p>e为阶码的位数。偏移量是把小数点移动到整数位只有1时移动的位数，正数表示向左移，负数表示向右移；</p></li><li><p>小数位：即二进制小数点后面的数。</p></li></ul><p>接下来把0.1转成的二进制0.0001100110011001 …转成浮点数形式的二进制。</p><ul><li><p>先要把小数点移动到整数位只有1，要向右移动4位，故偏移量为−4，通过指位数的计算公式</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-6aec50260c8d17f2?imageMogr2/auto-orient/strip|imageView2/2/w/163/format/webp" alt=""></p><p>把1019转成二进制为1111111011，不够11位要补零，最终得出指位数为01111111011；</p></li><li><p>小数位为100110011001… ，因为小数位只能保留52位，第53位为1故进1。</p></li></ul><p>转换结果如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-8022f3862919200e?imageMogr2/auto-orient/strip|imageView2/2/w/759/format/webp" alt=""></p><p>图片</p><p>同理，再把 0.2 转成的二进制0.0011 0011 0011 0011… 转成浮点数形式的二进制，转换结果如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-60707314104514a9?imageMogr2/auto-orient/strip|imageView2/2/w/740/format/webp" alt=""></p><h3 id="浮点数相加" tabindex="-1"><a class="header-anchor" href="#浮点数相加" aria-hidden="true">#</a> 浮点数相加</h3><p>浮点数相加时，需要先比较指位数是否一致，如果一致则小数位直接相加，如果不一致，要先把指位数调成一致的，指位数小的向大的调整。</p><p>为了行文方便，把0.1转成的浮点数称为为0.1，把0.2转成的浮点数称为0.2。</p><p>0.1的指数位是1019 ，0.2的指数位是1020 。故要把0.1的指数位加1，即把0.1的小数点向左移动1位，另外浮点数的整数位固定为1，过程如下所示</p><p>1.1001100110011001100110011001100110011001100110011010 原先 0.11001100110011001100110011001100110011001100110011010 移动后 0.1100110011001100110011001100110011001100110011001101 将小数的第53位舍去，因为为0故不需进1</p><p>导致0.1的小数位变成如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-ea5741f0e2d7784c?imageMogr2/auto-orient/strip|imageView2/2/w/824/format/webp" alt=""></p><p>现在0.1和0.2的指数位相同了，把小数位直接相加。</p><p>1100110011001100110011001100110011001100110011001101 0.1的小数位</p><ul><li>1001100110011001100110011001100110011001100110011010 0.2的小数位 = 10110011001100110011001100110011001100110011001100111</li></ul><p>会发现现在的小数位多出了一位，超出了52位，故要把小数位最后一位截掉，小数位最后一位是1，故要进1，如下所示：</p><p>10110011001100110011001100110011001100110011001100111 1011001100110011001100110011001100110011001100110100</p><p>截掉小数位的最后一位相当把小数点向左移了一位，故指数位要加1，此时的指数是0.2的指数1021 ，加1后变成1021 ，转成二进制为01111111101 ，那么相加后的浮点数如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-ad01e797a9d4583e?imageMogr2/auto-orient/strip|imageView2/2/w/739/format/webp" alt=""></p><h3 id="浮点数转成十进制" tabindex="-1"><a class="header-anchor" href="#浮点数转成十进制" aria-hidden="true">#</a> 浮点数转成十进制</h3><p>二进制浮点数计算结束后，把结果（二进制的浮点数）转成十进制，其转换公式为</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-82e7c2d2dec3da24?imageMogr2/auto-orient/strip|imageView2/2/w/291/format/webp" alt=""></p><p>，s是符号位为0或1，e为浮点数指数位转成十进制的值，i表示小数位从左到右的位数，第一位 i=1 ，</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-7fa2942a29a09cfa?imageMogr2/auto-orient/strip|imageView2/2/w/29/format/webp" alt=""></p><p>表示每一位的值为0或1。</p><p>那么按着公式把二进制的浮点数转成十进制：</p><p><img src="https://upload-images.jianshu.io/upload_images/24334532-2201d42cc9a27562?imageMogr2/auto-orient/strip|imageView2/2/w/424/format/webp" alt=""></p><p>结果如下所示：</p><p>0.3000000000000000444089209850062616169452667236328125</p><p>由于精度问题，只取到0.30000000000000004。</p><h2 id="答案" tabindex="-1"><a class="header-anchor" href="#答案" aria-hidden="true">#</a> 答案</h2><p>0.1+0.2 不等于 0.3 ，因为在 0.1+0.2 的计算过程中发生了两次精度丢失。第一次是在 0.1 和 0.2 转成双精度二进制浮点数时，由于二进制浮点数的小数位只能存储52位，导致小数点后第53位的数要进行为1则进1为0则舍去的操作，从而造成一次精度丢失。第二次在 0.1 和 0.2 转成二进制浮点数后，二进制浮点数相加的过程中，小数位相加导致小数位多出了一位，又要让第53位的数进行为1则进1为0则舍去的操作，又造成一次精度丢失。最终导致 0.1+0.2 不等于0.3 。</p>',44),r=[o];function s(d,l){return a(),i("div",null,r)}const m=p(t,[["render",s],["__file","JSzhong0.1_0.2weishimebudengyu0.3.html.vue"]]);export{m as default};
