import{_ as i,o as s,c as e,a as o}from"./app-ff2f634e.js";const a={},l=o("<p>Async/await：是一个用同步思维解决异步问题的方案</p><ol><li>会自动将常规函数转换成Promise，返回值也是一个Promise对象</li><li>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数</li><li>异步函数内部可以使用await</li><li>await 放置在Promise调用之前，await 强制后面点代码等待，直到Promise对象resolve，得到resolve的值作为await表达式的运算结果</li><li>await只能在async函数内部使用,用在普通函数里就会报错</li></ol><p>和Promise相比较 <strong>相同点</strong>：</p><p>为了解决异步流程问题，promise是约定，而async更优雅</p><p><strong>区别</strong>：</p><ol><li>Promise是ES6，而async是ES7</li><li>Promise原来有规范的意义，Promise a，b，c，d 等规范，最终确定的是Promise a+ 规范</li><li>Promise链式操作，自己catch异常。async则要在函数内catch，好在现在catch成本较低</li><li>Promise有很多并行神器，比如Promise.all\\Promise.race等。这些是async没法搞定的</li><li>Promise是显式的异步，而 Async/await 让你的代码看起来是同步的，你依然需要注意异步</li><li>Promise即使不支持es6，你依然可以用promise的库或polyfil，而async就很难做，当然也不是不能，成本会高很多</li><li>async functions 和Array.forEach等结合，很多tc39提案都在路上或者已经实现，处于上升期，而promise也就那样了</li></ol>",6),r=[l];function c(t,n){return s(),e("div",null,r)}const h=i(a,[["render",c],["__file","shimeshiAsync await，hePromiseyoushimequbie.html.vue"]]);export{h as default};
